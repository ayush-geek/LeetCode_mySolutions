class   DSU 
  { 
  private :  
     vector < int >  rank ,  parent ,  size ; 
   
  public : 
      DSU ( int  n ) 
      { 
         rank . resize ( n + 1 , 0 ) ; 
         parent . resize ( n + 1 ) ; 
         size . resize ( n + 1 , 1 ) ; 
 
          for ( int  i = 0 ; i <= n ; i ++ ) 
             parent [ i ] = i ; 
      } ; 
    
      int   findUPar ( int  u ) 
      { 
          if ( u == parent [ u ] ) 
              return  u ; 
 
          return  parent [ u ] = findUPar ( parent [ u ] ) ; 
      } 
 
      void   unionByRank ( int  u , int  v ) 
      { 
          int  ulp_u = findUPar ( u ) ; 
          int  ulp_v = findUPar ( v ) ; 
 
          if ( ulp_u == ulp_v )    
              return   ; 
 
          if ( rank [ ulp_u ] < rank [ ulp_v ] ) 
          { 
             parent [ ulp_u ] = ulp_v ; 
              //rank[ulp_v]++; 
             
          } 
          else    if ( rank [ ulp_u ] > rank [ ulp_v ] ) 
          { 
             parent [ ulp_v ] = ulp_u ; 
              // rank[ulp_u]++; 
          } 
          else { 
              parent [ ulp_u ] = ulp_v ; 
             rank [ ulp_v ] ++ ; 
          } 
 
      } 
 
 
       void   unionBySize ( int  u , int  v ) 
      { 
          int  ulp_u = findUPar ( u ) ; 
          int  ulp_v = findUPar ( v ) ; 
 
          if ( ulp_u == ulp_v )    
              return   ; 
 
          if ( size [ ulp_u ] <= size [ ulp_v ] ) 
          { 
             parent [ ulp_u ] = ulp_v ; 
             size [ ulp_v ] += size [ ulp_u ] ; 
             
          } 
          else 
          { 
             parent [ ulp_v ] = ulp_u ; 
             size [ ulp_u ] += size [ ulp_v ] ; 
          } 
 
      } 
 
 
  } ; 
 
 
  class   Solution   { 
  public : 
     vector < vector < string >>   accountsMerge ( vector < vector < string >> &  accounts )   { 
         vector < vector < string >>  res ; 
          int  n = accounts . size ( ) ; 
         DSU  ds ( n ) ; 
         unordered_map < string , int >  mp ; 
 
          for ( int  i = 0 ; i < n ; i ++ ) 
          { 
 
              for ( int  j = 1 ; j < accounts [ i ] . size ( ) ; j ++ ) 
              { 
                 string s = accounts [ i ] [ j ] ; 
                  if ( mp . find ( s ) == mp . end ( ) ) 
                     mp [ s ] = i ; 
                  else { 
                   
                     ds . unionBySize ( i , mp [ s ] ) ; 
                      } 
              } 
          } 
 
 
 
         vector < string >  tmp [ n ] ; 
          for ( auto  itr :  mp ) 
          { 
              int  z = ds . findUPar ( itr . second ) ; 
             string s = itr . first ; 
            
                 tmp [ z ] . push_back ( s ) ; 
            
          } 
 
 
 
          for ( int  i = 0 ; i < n ; i ++ ) 
          { 
             if ( tmp [ i ] . size ( ) != 0 ) 
              { 
                   sort ( tmp [ i ] . begin ( ) , tmp [ i ] . end ( ) ) ; 
                  vector < string >  tt ; 
                  tt . push_back ( accounts [ i ] [ 0 ] ) ; 
 
                   for ( auto  it : tmp [ i ] ) 
                     tt . push_back ( it ) ; 
                 res . push_back ( tt ) ; 
              } 
          } 
 
      return  res ; 
 
      } 
  } ;