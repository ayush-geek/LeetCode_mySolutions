class   Graph   { 
 public : 
     
     vector < vector < int >>  adj [ 101 ] ; 
      Graph ( int  n ,  vector < vector < int >> &  edges )   { 
          // adj.resize(n); 
         
          for ( auto &  ele :  edges ) 
          { 
             adj [ ele [ 0 ] ] . push_back ( { ele [ 1 ] , ele [ 2 ] } ) ; 
          } 
      } 
     
      void   addEdge ( vector < int >  ele )   { 
         adj [ ele [ 0 ] ] . push_back ( { ele [ 1 ] , ele [ 2 ] } ) ; 
      } 
     
      int   shortestPath ( int  node1 ,   int  node2 )   { 
        
         
          //Dijkstra 
         vector < int >   dis ( 101 , INT_MAX ) ; 
         priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >> >  pq ; 
         dis [ node1 ] = 0 ; 
         pq . push ( { 0 , node1 } ) ; 
         
          while ( ! pq . empty ( ) ) 
          { 
              auto  node = pq . top ( ) ; 
             pq . pop ( ) ; 
              int  d = node . first ; 
              int  nd = node . second ; 
              for ( auto &  ele :  adj [ nd ] ) 
              { 
                  int  v = ele [ 0 ] ; 
                  int  w = ele [ 1 ] ; 
                 
                  if ( d + w < dis [ v ] ) 
                  { 
                     dis [ v ] = d + w ; 
                     pq . push ( { d + w , v } ) ; 
                  } 
              } 
          } 
         
         
          if ( dis [ node2 ] == INT_MAX ) 
                  return   - 1 ; 
          else 
              return  dis [ node2 ] ; 
      } 
 } ; 
 
 /**
  * Your Graph object will be instantiated and called as such:
  * Graph* obj = new Graph(n, edges);
  * obj->addEdge(edge);
  * int param_2 = obj->shortestPath(node1,node2);
  */