class   Solution   { 
 public : 
     
      // void dfs(int i,vector<int> adj[],vector<int>& ct,int& ans,int par,vector<int>& vis) 
      // { 
      //     vis[i]=1; 
      //     if(par!=-1) 
      //     ct[i]+=ct[par]; 
      //     ct[i]++; 
      //     for(auto&ele: adj[i]) 
      //     { 
      //         if(!vis[ele]) 
      //                 dfs(ele,adj,ct,ans,i,vis); 
      //         else if(vis[ele] &&  ele!=par ) 
      //         {    
      //             //if(abs(ct[i]-ct[ele])+1>=3) 
      //             { ans=min(ans,abs(ct[i]-ct[ele])+1); 
      //             // cout<<"gh"<<ele<<" "<<par<<endl; 
      //             // cout<<i<<" "<<ele<<" "<<par<<endl; 
      //            cout<<ans<<endl; 
      //             ct[ele]=ct[i]+1; 
      //             cout<<ele<<" "<<ct[ele]<<endl;} 
      //         } 
             
      //     } 
         
     
      // } 
     
      int   findShortestCycle ( int  n ,  vector < vector < int >> &  edges )   { 
         
          //wth  
          //know understood why dfs fails 
 
 
         
         vector < int >  adj [ n ] ; 
          int  res = 1e9 ; 
          for ( auto & ele :  edges ) 
          { 
                 adj [ ele [ 0 ] ] . push_back ( ele [ 1 ] ) ; 
             adj [ ele [ 1 ] ] . push_back ( ele [ 0 ] ) ; 
          } 
          // vector<int> par(n+1,-1); 
        
         queue < pair < int , int >>  q ; 
          int  ans = 1e9 ; 
          for ( int  i = 0 ; i < n ; i ++ ) 
          { 
       vector < int >   dis ( n + 1 , - 1 ) ; 
         q . push ( { i , - 1 } ) ; 
         dis [ i ] = 0 ; 
          // vis[i]=1; 
          while ( ! q . empty ( ) ) 
          {    
              auto  ele = q . front ( ) ; 
              int  nd = ele . first ; 
              int  par = ele . second ; 
             q . pop ( ) ; 
 
              for ( auto &  el :  adj [ nd ] ) 
              { 
                  if ( dis [ el ] == - 1 ) 
                      { 
                         
                         dis [ el ] = 1 + dis [ nd ] ; 
                         q . push ( { el , nd } ) ; 
                      } 
                  else   if ( el != par ) 
                  { 
                     ans = min ( ans , dis [ el ] + dis [ nd ] + 1 ) ; 
                      //cout<<el<<" "<<par<<" "<<ans<<endl; 
                  } 
              } 
          } 
          } 
        
          if ( ans == 1e9 )   return   - 1 ; 
          return  ans ; 
      } 
 } ; 
 
 /*
 8
 [[1,3],[3,5],[5,7],[7,1],[0,2],[2,4],[4,0],[6,0],[6,1]]
 
 8
 [[0,1],[1,2],[2,3],[3,4],[4,5],[0,7],[0,6],[5,7],[5,6]]
 
 
 
 7
 [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
 4
 [[0,1],[0,2]]
 8
 [[1,3],[3,5],[5,7],[7,1],[0,2],[2,4],[4,0],[6,0],[6,1]]
 8
 [[0,1],[1,2],[2,3],[3,4],[4,5],[0,7],[0,6],[5,7],[5,6]]
 */