class   dsu 
 { 
 public : 
 	vector < int >  rank , parent , size ; 
 	 dsu ( int  n ) { 
 		rank . resize ( n + 1 , 0 ) ; 
 		parent . resize ( n + 1 ) ; 
 		size . resize ( n + 1 , 1 ) ; 
 
 		 for ( int  i = 0 ; i <= n ; i ++ ) 
 			parent [ i ] = i ; 
 	 } 
 
 	 int   findUpar ( int  node ) 
 	 { 
 		 if ( node == parent [ node ] ) 
 			 return  node ; 
 
 		 return  parent [ node ] = findUpar ( parent [ node ] ) ; 
 
 	 } 
 
 
 	 void   unionBySize ( int  u , int  v ) 
 	 { 	
 		 int  up_u = findUpar ( u ) ; 
 		 int  up_v = findUpar ( v ) ; 
 		 if ( up_u  ==  up_v ) 
 			 return   ; 
 
 		 if ( size [ up_u ] < size [ up_v ] ) { 
 			parent [ up_u ] = up_v ; 
 			size [ up_v ] += size [ up_u ] ; 
 		 } 
 		
 		 else 
 		 { 
 			parent [ up_v ] = up_u ; 
 			size [ up_u ] += size [ up_v ] ; 
 		 } 
 
 	 } 
 	
 	
 } ; 
 
 class   Solution   { 
 public : 
      int   makeConnected ( int  n ,  vector < vector < int >> &  connections )   { 
         
          if ( connections . size ( ) < n - 1 ) 
              return   - 1 ; 
 
         dsu  ds ( n ) ; 
 
          for ( int  i = 0 ; i < connections . size ( ) ; i ++ ) 
          { 
              int  u = connections [ i ] [ 0 ] ; 
              int  v = connections [ i ] [ 1 ] ; 
             
              if ( ds . findUpar ( u ) != ds . findUpar ( v ) ) 
              { 
                 ds . unionBySize ( u , v ) ; 
              } 
          } 
          int  ct = 0 ; 
          for ( int  i = 0 ; i < n ; i ++ ) 
          { 
              if ( ds . parent [ i ] == i ) 
                 ct ++ ; 
          } 
 
          return  ct - 1 ; 
         
      } 
 } ;